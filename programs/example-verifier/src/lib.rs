//! Example Solana Verifier Program
//!
//! This is a template for a circuit-specific verifier program.
//! The VK would be embedded as constants (generated by vk-codegen).

use plonk_solana_core::{verify, Fr, VerifyError, VK_SIZE};
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg,
    program_error::ProgramError, pubkey::Pubkey,
};

// Entry point
entrypoint!(process_instruction);

/// Custom error codes
#[derive(Debug)]
pub enum VerifierProgramError {
    InvalidInstructionData = 0,
    VerificationFailed = 1,
    InvalidPublicInputs = 2,
    InvalidProofFormat = 3,
    InvalidVkFormat = 4,
}

impl From<VerifierProgramError> for ProgramError {
    fn from(e: VerifierProgramError) -> Self {
        ProgramError::Custom(e as u32)
    }
}

impl From<VerifyError> for VerifierProgramError {
    fn from(e: VerifyError) -> Self {
        match e {
            VerifyError::Proof(_) => VerifierProgramError::InvalidProofFormat,
            VerifyError::Key(_) => VerifierProgramError::InvalidVkFormat,
            VerifyError::PublicInput(_) => VerifierProgramError::InvalidPublicInputs,
            _ => VerifierProgramError::VerificationFailed,
        }
    }
}

/// Process instruction
///
/// Instruction data format:
/// - [0..4]: Number of public inputs (u32 big-endian)
/// - [4..4+num_inputs*32]: Public inputs (32 bytes each)
/// - [remaining..]: Proof (PROOF_SIZE bytes)
pub fn process_instruction(
    _program_id: &Pubkey,
    _accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("Processing verify instruction");

    // For simplicity in this example, we use embedded VK constants
    // In production, VK would be generated by vk-codegen
    let vk_bytes = get_embedded_vk();

    // Parse instruction data
    if instruction_data.len() < 4 {
        return Err(VerifierProgramError::InvalidInstructionData.into());
    }

    // Read number of public inputs
    let num_inputs = u32::from_be_bytes([
        instruction_data[0],
        instruction_data[1],
        instruction_data[2],
        instruction_data[3],
    ]) as usize;

    let inputs_size = num_inputs * 32;
    let min_size = 4 + inputs_size; // At minimum need header + inputs

    if instruction_data.len() < min_size {
        msg!(
            "Instruction data too small: {} < {}",
            instruction_data.len(),
            min_size
        );
        return Err(VerifierProgramError::InvalidInstructionData.into());
    }

    // Parse public inputs
    let inputs_start = 4;
    let inputs_end = inputs_start + inputs_size;
    let mut public_inputs: Vec<Fr> = Vec::with_capacity(num_inputs);
    for chunk in instruction_data[inputs_start..inputs_end].chunks(32) {
        let mut arr = [0u8; 32];
        arr.copy_from_slice(chunk);
        public_inputs.push(arr);
    }

    // Parse proof (variable size, validated by verifier based on VK's log_circuit_size)
    let proof_bytes = &instruction_data[inputs_end..];

    msg!(
        "Verifying proof with {} public inputs, proof size {}",
        public_inputs.len(),
        proof_bytes.len()
    );

    // Verify
    // is_zk = true for default Keccak proofs (generated without --disable_zk)
    let is_zk = true;
    match verify(&vk_bytes, proof_bytes, &public_inputs, is_zk) {
        Ok(()) => {
            msg!("Proof verification PASSED");
            Ok(())
        }
        Err(e) => {
            msg!("Proof verification FAILED: {:?}", e);
            Err(VerifierProgramError::from(e).into())
        }
    }
}

/// Get the embedded verification key
///
/// In a real deployment, this would contain the actual VK constants
/// generated by vk-codegen from the circuit's vk binary
fn get_embedded_vk() -> [u8; VK_SIZE] {
    // Placeholder - replace with actual VK from vk-codegen
    // This is a minimal valid VK structure for bb 3.0 UltraHonk:
    // - log2_circuit_size = 6 (circuit size = 64)
    // - log2_domain_size = 17 (domain size = 131072)
    // - num_public_inputs = 17 (1 inner + 16 pairing points)
    // - 28 G1 commitments (all zeros for placeholder)
    let mut vk = [0u8; VK_SIZE];

    // log2_circuit_size = 6
    vk[31] = 6;
    // log2_domain_size = 17
    vk[63] = 17;
    // num_public_inputs = 17 (1 inner public input + 16 pairing point object)
    vk[95] = 17;

    // Note: In production, all G1 commitments would be real values
    // from the circuit's verification key

    vk
}

// Vec is from alloc
extern crate alloc;
use alloc::vec::Vec;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embedded_vk_structure() {
        let vk = get_embedded_vk();
        assert_eq!(vk.len(), VK_SIZE);
        // log2_circuit_size = 6
        assert_eq!(vk[31], 6);
        // log2_domain_size = 17
        assert_eq!(vk[63], 17);
        // num_public_inputs = 17 (1 inner + 16 pairing points)
        assert_eq!(vk[95], 17);
    }
}
