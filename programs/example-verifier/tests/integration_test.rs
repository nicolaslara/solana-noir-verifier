//! Integration test for the verifier program
//!
//! This test demonstrates the e2e workflow:
//! 1. Load proof and VK generated by Noir/Barretenberg
//! 2. Call the Solana verifier program
//! 3. Check the result
//!
//! To generate test artifacts:
//! ```bash
//! cd test-circuits/simple_square
//! nargo compile
//! nargo execute
//! ~/.bb/bb prove -b ./target/simple_square.json -w ./target/simple_square.gz \
//!     --oracle_hash keccak --write_vk -o ./target/keccak
//! ```

#[allow(deprecated)] // solana-program-test deprecation warnings
use solana_program_test::*;
use solana_sdk::{
    instruction::Instruction, pubkey::Pubkey, signature::Signer, transaction::Transaction,
};
use std::path::PathBuf;

/// Load the example verifier program
#[allow(deprecated)]
fn program_test() -> ProgramTest {
    ProgramTest::new(
        "example_verifier",
        example_verifier_id(),
        processor!(example_verifier::process_instruction),
    )
}

/// Program ID (this would be the deployed program address)
/// Using a deterministic ID for testing
fn example_verifier_id() -> Pubkey {
    solana_sdk::pubkey!("FxZvYvE6NNEGwPqQiZhMp3aDzDiY9j5nnj2jDxMjZkz5")
}

/// Get the path to test-circuits relative to the workspace root
fn test_circuits_path() -> PathBuf {
    // tests run from programs/example-verifier, so go up two levels
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop(); // up from programs/example-verifier
    path.pop(); // up from programs
    path.push("test-circuits");
    path
}

#[tokio::test]
async fn test_verify_proof_e2e() {
    // Start the test validator
    let (banks_client, payer, recent_blockhash) = program_test().start().await;

    // Load proof from bb output (Keccak oracle hash)
    let circuits_path = test_circuits_path();
    let proof_path = circuits_path.join("simple_square/target/keccak/proof");
    let public_inputs_path = circuits_path.join("simple_square/target/keccak/public_inputs");

    // Try to load real proof files
    let (proof, public_inputs) = match (
        std::fs::read(&proof_path),
        std::fs::read(&public_inputs_path),
    ) {
        (Ok(proof), Ok(pi)) => {
            println!("‚úÖ Loaded real proof from {:?}", proof_path);
            println!("   Proof size: {} bytes", proof.len());
            println!("   Public inputs size: {} bytes", pi.len());
            (proof, pi)
        }
        _ => {
            println!("‚ö†Ô∏è  Proof files not found, using placeholder data");
            println!("   Run: cd test-circuits/simple_square && nargo compile && nargo execute");
            println!("   Then: ~/.bb/bb prove -b ./target/simple_square.json -w ./target/simple_square.gz --oracle_hash keccak --write_vk -o ./target/keccak");

            // Use placeholder data for log_n=6, ZK proof (162 Fr = 5184 bytes)
            let proof_size = plonk_solana_core::proof::Proof::expected_size(6, true) * 32;
            let proof = vec![0u8; proof_size];
            let mut pi = vec![0u8; 32];
            pi[31] = 9; // y = 9
            (proof, pi)
        }
    };

    // Parse public inputs (each is 32 bytes)
    let num_public_inputs = (public_inputs.len() / 32) as u32;

    // Build instruction data: [num_inputs (4 bytes)] [inputs...] [proof...]
    let mut instruction_data = Vec::new();
    instruction_data.extend_from_slice(&num_public_inputs.to_be_bytes());
    instruction_data.extend_from_slice(&public_inputs);
    instruction_data.extend_from_slice(&proof);

    // Create the instruction
    let instruction = Instruction {
        program_id: example_verifier_id(),
        accounts: vec![], // No accounts needed for verification
        data: instruction_data,
    };

    // Build and send transaction
    let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));
    transaction.sign(&[&payer], recent_blockhash);

    // Execute - expect this to fail since verification is not fully implemented
    let result = banks_client.process_transaction(transaction).await;

    // For now, we expect a failure (verification not implemented)
    // Once implemented, this should succeed with a valid proof
    match result {
        Ok(()) => {
            println!("‚úÖ Transaction succeeded (verification passed!)");
        }
        Err(e) => {
            println!(
                "‚ùå Transaction failed (expected while verification incomplete): {:?}",
                e
            );
            // Check it's the right kind of failure (verification failed, not parse error)
            let error_str = format!("{:?}", e);
            assert!(
                error_str.contains("Custom") || error_str.contains("Program"),
                "Expected program error, got: {}",
                error_str
            );
        }
    }
}

#[tokio::test]
async fn test_verify_with_real_proof() {
    // Print current status of e2e workflow
    println!("\n=== E2E Workflow Status ===");
    println!("1. ‚úÖ Noir circuit compilation (nargo compile)");
    println!("2. ‚úÖ Witness generation (nargo execute)");
    println!("3. ‚úÖ Proof generation (bb prove --oracle_hash keccak)");
    println!("4. ‚úÖ External verification (bb verify --oracle_hash keccak)");
    println!("5. ‚úÖ Solana program test setup");
    println!("6. ‚úÖ VK/Proof parsing for bb 3.0 UltraHonk format");
    println!("7. üöß UltraHonk verification algorithm (in progress)");
    println!("===========================\n");

    // Check if proof files exist
    let circuits_path = test_circuits_path();
    let proof_path = circuits_path.join("simple_square/target/keccak/proof");
    let vk_path = circuits_path.join("simple_square/target/keccak/vk");
    let pi_path = circuits_path.join("simple_square/target/keccak/public_inputs");

    if proof_path.exists() && vk_path.exists() && pi_path.exists() {
        println!("‚úÖ Test artifacts found:");
        println!(
            "   VK: {} bytes",
            std::fs::metadata(&vk_path).map(|m| m.len()).unwrap_or(0)
        );
        println!(
            "   Proof: {} bytes",
            std::fs::metadata(&proof_path).map(|m| m.len()).unwrap_or(0)
        );
        println!(
            "   Public inputs: {} bytes",
            std::fs::metadata(&pi_path).map(|m| m.len()).unwrap_or(0)
        );
    } else {
        println!("‚ö†Ô∏è  Test artifacts not found. Generate with:");
        println!("   cd test-circuits/simple_square");
        println!("   nargo compile && nargo execute");
        println!("   ~/.bb/bb prove -b ./target/simple_square.json -w ./target/simple_square.gz --oracle_hash keccak --write_vk -o ./target/keccak");
    }
}
