//! Integration test for Groth16 verifier on Solana
//!
//! Run with: cargo test

use solana_program_test::*;
use solana_sdk::{
    instruction::Instruction,
    signature::Signer,
    transaction::Transaction,
};

/// The proof generated by gnark for x=3, y=9
/// From gnark/output/proof.bin (256 bytes)
/// gnark's MarshalSolidity outputs proof ready for Solidity/Solana verification
const PROOF: &[u8] = include_bytes!("../../gnark/output/proof.bin");

/// The public input: y = 9 as a 32-byte big-endian field element
const PUBLIC_INPUT: &[u8] = include_bytes!("../../gnark/output/public.bin");

fn program_test() -> ProgramTest {
    ProgramTest::new(
        "groth16_verifier",
        groth16_verifier::id(),
        processor!(groth16_verifier::process_instruction),
    )
}

#[tokio::test]
async fn test_groth16_verify_valid_proof() {
    let mut pt = program_test();
    pt.set_compute_max_units(400_000); // Set high limit to measure actual usage
    let (mut banks_client, payer, recent_blockhash) = pt.start().await;

    // Build instruction data: proof (256 bytes) + public_input (32 bytes)
    let mut instruction_data = Vec::with_capacity(256 + 32);
    instruction_data.extend_from_slice(PROOF);
    instruction_data.extend_from_slice(PUBLIC_INPUT);

    println!("=== Groth16 Verification Test ===");
    println!("Proof size: {} bytes", PROOF.len());
    println!("Public input size: {} bytes", PUBLIC_INPUT.len());
    println!("Total instruction data: {} bytes", instruction_data.len());
    println!("Public input (y): {:?}", &PUBLIC_INPUT[28..32]); // Last 4 bytes show value

    let instruction = Instruction {
        program_id: groth16_verifier::id(),
        accounts: vec![],
        data: instruction_data,
    };

    let mut transaction = Transaction::new_with_payer(
        &[instruction], 
        Some(&payer.pubkey())
    );
    transaction.sign(&[&payer], recent_blockhash);

    // Execute transaction
    let result = banks_client.process_transaction(transaction).await;

    match result {
        Ok(_) => println!("✅ Groth16 proof verified successfully!"),
        Err(e) => {
            println!("❌ Verification failed: {:?}", e);
            panic!("Proof verification should have succeeded");
        }
    }
}

#[tokio::test]
async fn test_groth16_verify_invalid_proof() {
    let (mut banks_client, payer, recent_blockhash) = program_test().start().await;

    // Create an invalid proof by modifying bytes
    let mut invalid_proof = PROOF.to_vec();
    invalid_proof[10] ^= 0xFF; // Flip bits to make it invalid

    let mut instruction_data = Vec::with_capacity(256 + 32);
    instruction_data.extend_from_slice(&invalid_proof);
    instruction_data.extend_from_slice(PUBLIC_INPUT);

    let instruction = Instruction {
        program_id: groth16_verifier::id(),
        accounts: vec![],
        data: instruction_data,
    };

    let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));
    transaction.sign(&[&payer], recent_blockhash);

    let result = banks_client.process_transaction(transaction).await;

    match result {
        Ok(_) => panic!("Invalid proof should have been rejected"),
        Err(_) => println!("✅ Invalid proof correctly rejected"),
    }
}

#[tokio::test]
async fn test_groth16_verify_wrong_public_input() {
    let (mut banks_client, payer, recent_blockhash) = program_test().start().await;

    // Create wrong public input (y = 10 instead of 9)
    let mut wrong_public_input = [0u8; 32];
    wrong_public_input[31] = 10; // y = 10 (big-endian)

    let mut instruction_data = Vec::with_capacity(256 + 32);
    instruction_data.extend_from_slice(PROOF);
    instruction_data.extend_from_slice(&wrong_public_input);

    let instruction = Instruction {
        program_id: groth16_verifier::id(),
        accounts: vec![],
        data: instruction_data,
    };

    let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));
    transaction.sign(&[&payer], recent_blockhash);

    let result = banks_client.process_transaction(transaction).await;

    match result {
        Ok(_) => panic!("Wrong public input should have been rejected"),
        Err(_) => println!("✅ Wrong public input correctly rejected"),
    }
}
