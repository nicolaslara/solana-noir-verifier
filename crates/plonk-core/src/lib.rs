//! UltraHonk verifier for Noir proofs on Solana
//!
//! This crate provides verification of UltraHonk proofs generated by Noir's
//! Barretenberg backend (bb v0.84.0+). It uses Solana's BN254 syscalls for all curve operations,
//! providing a single code path for both on-chain and local testing (via solana-program-test).
//!
//! # Format (bb v0.84.0+ with --oracle_hash keccak)
//!
//! - **VK**: 1888 bytes (3 header fields + 28 G1 commitments)
//! - **Proof**: Variable size based on `log_circuit_size` (log_n)
//!   - For log_n=6 (circuit_size=64): 5184 bytes (ZK) or 4512 bytes (non-ZK)
//!   - Contains: pairing_points + commitments + sumcheck_data + gemini_data + opening_proofs
//! - **Public inputs**: 32 bytes per input (big-endian Fr)
//!
//! # Key Discovery
//!
//! The proof size scales with `log_circuit_size`, NOT the constant `CONST_PROOF_SIZE_LOG_N=28`.
//! For a small circuit with log_n=6, sumcheck has 6 rounds (not 28), making the proof much smaller.
//! The proof DOES contain inline sumcheck data (univariates + evaluations).
//!
//! # Architecture
//!
//! - Uses raw byte arrays for curve points and field elements
//! - All curve operations go through `solana-bn254` syscalls
//! - Uses Keccak256 for Fiat-Shamir transcript (matches bb --oracle_hash keccak)

extern crate alloc;

pub mod constants;
pub mod debug;
pub mod errors;
pub mod field;
pub mod key;
pub mod ops;
pub mod proof;
pub mod relations;
pub mod shplemini;
pub mod sumcheck;
pub mod transcript;
pub mod types;
pub mod verifier;

// Re-export main types
pub use errors::VerifyError;
pub use types::{Fr, Scalar, G1, G2};
pub use verifier::{
    // Split delta computation
    compute_delta_part1,
    compute_delta_part2,
    // Incremental challenge generation for multi-TX verification
    generate_challenges_phase1a,
    generate_challenges_phase1b,
    generate_challenges_phase1c,
    generate_challenges_phase1d,
    verify,
    verify_inner,
    verify_step1_challenges,
    verify_step2_sumcheck,
    verify_step3_pairing_points,
    verify_step4_pairing_check,
    Challenges,
    DeltaPartialResult,
    Phase1aResult,
    Phase1bResult,
    Phase1cResult,
    Phase1dResult,
    RelationParameters,
};

// Re-export incremental sumcheck types and functions
pub use sumcheck::{
    sumcheck_rounds_init, verify_sumcheck_relations, verify_sumcheck_rounds_partial,
    SumcheckRoundsState,
};

// Re-export incremental shplemini (MSM) types and functions
pub use shplemini::{
    shplemini_phase3a, shplemini_phase3b, shplemini_phase3b1, shplemini_phase3b2,
    shplemini_phase3c, ShpleminiPhase3aResult, ShpleminiPhase3b1Result, ShpleminiPhase3bResult,
};

/// VK size for new format (bb v0.84.0+)
/// = 32-byte header + 27 G1 commitments (64 bytes each)
/// = 32 + 1728 = 1760 bytes
pub const VK_SIZE: usize = key::VK_SIZE_NEW;

/// VK size for old format (legacy)
/// = 96-byte header + 28 G1 commitments (64 bytes each)
/// = 96 + 1792 = 1888 bytes
pub const VK_SIZE_OLD: usize = key::VK_SIZE_OLD;

/// Proof size in bytes for bb v0.84.0+ UltraHonk (Keccak) with log_n=6, ZK
/// This is just a reference size - actual proof size depends on log_circuit_size
/// Use `proof::Proof::expected_size(log_n, is_zk)` to calculate for specific circuits
pub const PROOF_SIZE_LOG6_ZK: usize = 162 * 32; // 5184 bytes

/// Single public input size in bytes
pub const PUB_SIZE: usize = 32;

/// Number of G1 commitments in new VK format
pub const VK_NUM_COMMITMENTS: usize = key::VK_NUM_COMMITMENTS_NEW;

/// Number of G1 commitments in old VK format
pub const VK_NUM_COMMITMENTS_OLD: usize = key::VK_NUM_COMMITMENTS_OLD;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vk_size_calculation() {
        // New format: 32-byte header + 27 commitments
        assert_eq!(VK_SIZE, 32 + 27 * 64);
        assert_eq!(VK_SIZE, 1760);

        // Old format: 96-byte header + 28 commitments
        assert_eq!(VK_SIZE_OLD, 96 + 28 * 64);
        assert_eq!(VK_SIZE_OLD, 1888);
    }

    #[test]
    fn test_proof_size_zk() {
        // bb 0.87: All ZK proofs are fixed size (507 Fr elements = 16224 bytes)
        // regardless of actual circuit log_n
        let expected_size = proof::Proof::expected_size_bytes(true);
        assert_eq!(expected_size, 16224, "ZK proof should be 16224 bytes");

        // expected_size() returns Fr count, not bytes
        assert_eq!(proof::Proof::expected_size(6, true), 507);
        assert_eq!(proof::Proof::expected_size(12, true), 507);
        assert_eq!(proof::Proof::expected_size(20, true), 507);
    }
}
