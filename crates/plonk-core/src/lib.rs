//! UltraHonk verifier for Noir proofs on Solana
//!
//! This crate provides verification of UltraHonk proofs generated by Noir's
//! Barretenberg backend (bb 3.0+). It uses Solana's BN254 syscalls for all curve operations,
//! providing a single code path for both on-chain and local testing (via solana-program-test).
//!
//! # Format (bb 3.0 with --oracle_hash keccak)
//!
//! - **VK**: 1888 bytes (3 header fields + 28 G1 commitments)
//! - **Proof**: Variable size based on `log_circuit_size` (log_n)
//!   - For log_n=6 (circuit_size=64): 5184 bytes (ZK) or 4512 bytes (non-ZK)
//!   - Contains: pairing_points + commitments + sumcheck_data + gemini_data + opening_proofs
//! - **Public inputs**: 32 bytes per input (big-endian Fr)
//!
//! # Key Discovery
//!
//! The proof size scales with `log_circuit_size`, NOT the constant `CONST_PROOF_SIZE_LOG_N=28`.
//! For a small circuit with log_n=6, sumcheck has 6 rounds (not 28), making the proof much smaller.
//! The proof DOES contain inline sumcheck data (univariates + evaluations).
//!
//! # Architecture
//!
//! - Uses raw byte arrays for curve points and field elements
//! - All curve operations go through `solana-bn254` syscalls
//! - Uses Keccak256 for Fiat-Shamir transcript (matches bb --oracle_hash keccak)

extern crate alloc;

pub mod constants;
pub mod debug;
pub mod errors;
pub mod field;
pub mod key;
pub mod ops;
pub mod proof;
pub mod relations;
pub mod shplemini;
pub mod sumcheck;
pub mod transcript;
pub mod types;
pub mod verifier;

// Re-export main types
pub use errors::VerifyError;
pub use types::{Fr, Scalar, G1, G2};
pub use verifier::verify;

/// VK size in bytes for bb 3.0 UltraHonk (Keccak)
/// = 3 header fields (32 bytes each) + 28 G1 commitments (64 bytes each)
/// = 96 + 1792 = 1888
pub const VK_SIZE: usize = 1888;

/// Proof size in bytes for bb 3.0 UltraHonk (Keccak) with log_n=6, ZK
/// This is just a reference size - actual proof size depends on log_circuit_size
/// Use `proof::Proof::expected_size(log_n, is_zk)` to calculate for specific circuits
pub const PROOF_SIZE_LOG6_ZK: usize = 162 * 32; // 5184 bytes

/// Single public input size in bytes
pub const PUB_SIZE: usize = 32;

/// Number of G1 commitments in VK
pub const VK_NUM_COMMITMENTS: usize = 28;

/// Number of header fields in VK (each 32 bytes)
pub const VK_HEADER_FIELDS: usize = 3;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vk_size_calculation() {
        // VK = header + commitments
        let expected = VK_HEADER_FIELDS * 32 + VK_NUM_COMMITMENTS * 64;
        assert_eq!(VK_SIZE, expected);
    }

    #[test]
    fn test_proof_size_log6_zk() {
        // For log_n=6, ZK proof has 162 Fr elements
        assert_eq!(PROOF_SIZE_LOG6_ZK, 5184);
        assert_eq!(proof::Proof::expected_size(6, true), 162);
    }
}
