//! VK Codegen - Generate Rust verification key constants from Barretenberg VK binary
//!
//! This tool parses an UltraHonk verification key binary (from `bb prove --write_vk`)
//! and outputs Rust code with embedded byte arrays for a Solana verifier program.
//!
//! Usage:
//!   vk-codegen --vk ./target/keccak/vk --proof ./target/keccak/proof --output ./generated_vk.rs

use anyhow::{bail, Context, Result};
use clap::Parser;
use std::fs;
use std::path::PathBuf;

/// CLI arguments
#[derive(Parser, Debug)]
#[command(name = "vk-codegen")]
#[command(about = "Generate Rust VK constants from Barretenberg VK binary")]
struct Args {
    /// Path to VK binary file (from bb prove --write_vk)
    #[arg(long)]
    vk: PathBuf,

    /// Path to proof binary file (to determine proof size)
    #[arg(long)]
    proof: Option<PathBuf>,

    /// Path to public_inputs file (to determine number of public inputs)
    #[arg(long)]
    public_inputs: Option<PathBuf>,

    /// Output Rust file path
    #[arg(short, long)]
    output: PathBuf,

    /// Circuit name for the generated module
    #[arg(long, default_value = "circuit")]
    name: String,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Read VK binary
    let vk_bytes = fs::read(&args.vk)
        .with_context(|| format!("Failed to read VK from {}", args.vk.display()))?;

    // Read proof if provided (to get proof size)
    let proof_size = if let Some(proof_path) = &args.proof {
        let proof_bytes = fs::read(proof_path)
            .with_context(|| format!("Failed to read proof from {}", proof_path.display()))?;
        proof_bytes.len()
    } else {
        0
    };

    // Read public inputs if provided
    let num_public_inputs = if let Some(pi_path) = &args.public_inputs {
        let pi_bytes = fs::read(pi_path)
            .with_context(|| format!("Failed to read public inputs from {}", pi_path.display()))?;
        pi_bytes.len() / 32 // Each public input is 32 bytes
    } else {
        // Try to parse from VK binary (offset depends on format)
        parse_num_public_inputs(&vk_bytes)?
    };

    // Generate Rust code
    let rust_code = generate_rust_code(&args.name, &vk_bytes, proof_size, num_public_inputs)?;

    // Write output
    fs::write(&args.output, &rust_code)
        .with_context(|| format!("Failed to write {}", args.output.display()))?;

    println!(
        "âœ… Generated {} from {}",
        args.output.display(),
        args.vk.display()
    );
    println!("   VK size: {} bytes", vk_bytes.len());
    println!("   Proof size: {} bytes", proof_size);
    println!("   Public inputs: {}", num_public_inputs);

    Ok(())
}

/// Parse number of public inputs from VK binary
/// UltraHonk VK format: [circuit_size (32)] [log_circuit_size (32)] [num_public_inputs (32)] [commitments...]
fn parse_num_public_inputs(vk: &[u8]) -> Result<usize> {
    if vk.len() < 96 {
        bail!("VK too short to contain header");
    }

    // num_public_inputs is at offset 64, as a 32-byte big-endian integer
    // (but usually fits in last 4 bytes)
    let offset = 64;
    let value = u32::from_be_bytes([
        vk[offset + 28],
        vk[offset + 29],
        vk[offset + 30],
        vk[offset + 31],
    ]);
    Ok(value as usize)
}

fn generate_rust_code(
    name: &str,
    vk: &[u8],
    proof_size: usize,
    num_public_inputs: usize,
) -> Result<String> {
    let mut code = String::new();

    // Header
    code.push_str(&format!(
        r#"//! Generated verification key for circuit: {}
//!
//! VK size: {} bytes
//! Proof size: {} bytes  
//! Public inputs: {}
//!
//! Generated by vk-codegen. DO NOT EDIT.

/// Number of public inputs for this circuit
pub const NUM_PUBLIC_INPUTS: usize = {};

/// Expected proof size in bytes
pub const PROOF_SIZE: usize = {};

/// Verification key size in bytes
pub const VK_SIZE: usize = {};

/// Embedded verification key (binary format from bb)
pub const VK_BYTES: [u8; {}] = [
"#,
        name,
        vk.len(),
        proof_size,
        num_public_inputs,
        num_public_inputs,
        proof_size,
        vk.len(),
        vk.len(),
    ));

    // Write VK bytes
    for (i, byte) in vk.iter().enumerate() {
        if i % 16 == 0 {
            code.push_str("    ");
        }
        code.push_str(&format!("0x{:02x}, ", byte));
        if (i + 1) % 16 == 0 {
            code.push('\n');
        }
    }
    if !vk.len().is_multiple_of(16) {
        code.push('\n');
    }
    code.push_str("];\n");

    Ok(code)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_num_public_inputs() {
        // Create a minimal VK with num_public_inputs = 1 at offset 64
        let mut vk = vec![0u8; 128];
        vk[64 + 31] = 1; // num_public_inputs = 1

        let result = parse_num_public_inputs(&vk).unwrap();
        assert_eq!(result, 1);
    }
}
